summary(housing_raw)
str(housing_raw)
#is.na(housing_raw)
#na.omit(housing_raw)
housing_numeric <- subset(housing_raw, select = -c(CHAS,RAD))
#is.na(housing_raw)
#na.omit(housing_raw)
housing_numeric <- subset(housing_raw, select = -c(CHAS,RAD))
library(DMwR)
housing_numeric <- knnImputation(housing_numeric)
sum(is.na(housing_numeric))
rows <- seq(1, nrow(housing_numeric),1)
set.seed(123)
trainRows <- sample(rows, 70* nrow(housing_numeric)/100)
housing_train <- housing_numeric[trainRows,]
housing_test <- housing_numeric[-trainRows,]
x_train <- housing_train[, -ncol(housing_train)]
x_test <- housing_test[, -ncol(housing_test)]
y_train <- housing_train[, ncol(housing_train)]
y_test <- housing_test[, ncol(housing_test)]
pca <- princomp(x_train)
pca$scores
pca$loadings
pca_std <- princomp(x_train, cor = T)
summary(pca)
summary(pca_std)
pca_train = predict(pca, x_train)
pca_test = predict(pca, x_test)
pca_std_train = predict(pca_std, x_train)
pca_std_test = predict(pca_std, x_test)
# linear model without pca
train2 = data.frame(x_train, y_train)
test2 = data.frame(x_test,y_test)
LinReg <- lm( y_train ~ ., data=train2)
summary(LinReg)
library(DMwR)
#Error verificatoin on train data
regr.eval(train2$y_train, LinReg$fitted.values)
#Error verification on test data
pred <- predict(LinReg, test2)
regr.eval(test2$y_test,pred)
#using PCA
train3 = data.frame(pca_train[,1:3], y_train)
test3 = data.frame(pca_test[,1:3], y_test)
LinRegpca <- lm(y_train~., data = train3)
summary(LinRegpca)
regr.eval(train3$y_train, LinRegpca$fitted.values)
predpca = predict(LinRegpca, test3)
regr.eval(test3$y_test, predpca)
#using standard pca
train4 = data.frame(pca_train[,1:3], y_train)
test4 = data.frame(pca_test[,1:3], y_test)
summary(pca_std)
#using standard pca
train4 = data.frame(pca_train[,1:7], y_train)
test4 = data.frame(pca_test[,1:7], y_test)
LinRegstdpca <- lm(y_train~., data = train4)
summary(LinRegstdpca)
regr.eval(train4$y_train, LinRegstdpca$fitted.values)
predstdpca = predict(LinRegstdpca, test4)
regr.eval(test4$y_test, predstdpca)
rm(list=ls(all=TRUE))
getwd()
setwd('E://Insofe//Week7//Day2//Lab')
load("Data.RData")
str(data)
View(data)
library(sqldf) # to write SQL like commands in R to aggregate the data.
RtData2.Day <- sqldf("select Date,min(Price) as MIN_PRICE from data group by Date")
str(RtData2.Day)
View(RtData2.Day)
str(RtData2.Day)
head(RtData2.Day)
minDate=min(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# To find the maximum of the dates
maxDate =max(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# generating the series of dates
seq <- data.frame("dateRange"=seq(minDate,maxDate,by="days"))
View(seq)
# left joining to see the missing values for the dates. all.x will do the left join."all.y" will do right join.
RtData2.Day2= merge(seq,RtData2.Day,by.x="dateRange",by.y="Date",all.x=T)
head(RtData2.Day2)
rm(list=ls(all=TRUE))
getwd()
setwd('E://Insofe//Week7//Day2//Lab')
load("Data.RData")
str(data)
dim(data)
head(data)
names(data)
tail(data)
library(sqldf) # to write SQL like commands in R to aggregate the data.
RtData2.Day <- sqldf("select Date,min(Price) as MIN_PRICE from data group by Date")
str(RtData2.Day)
RtData2.Day$Date=as.Date(RtData2.Day$Date,format="%Y-%m-%d")
str(RtData2.Day)
head(RtData2.Day) # we have missing values 02nd jan doesnt have an entry
minDate=min(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# To find the maximum of the dates
maxDate =max(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# generating the series of dates
seq <- data.frame("dateRange"=seq(minDate,maxDate,by="days"))
# left joining to see the missing values for the dates. all.x will do the left join."all.y" will do right join.
RtData2.Day2= merge(seq,RtData2.Day,by.x="dateRange",by.y="Date",all.x=T)
head(RtData2.Day2)
#   Here is the example to understand how "na.locf()"  function works
library(zoo)
x <- c(NA,1,2,3,4,5,NA,NA,NA,7,8,NA)
# if you want to replace the missing value with its immediate neighbors, here is the R code. This code is to show that missing value is replaced with it's preceding and succeeding values
na.locf(x)
rev(na.locf(rev(x)))
# if you want to replace the missing value with its immediate neighbors, here is the R code. This code is to show that missing value is replaced with it's preceding and succeeding values
na.locf(x)
rev(na.locf(rev(x)))
(na.locf(x) + rev(na.locf(rev(x))))/2
x <- c(NA,1,2,3,4,5,NA,NA,NA,7,8,NA)
# na.locf function is used to replace the missing values. This will replace the missing value with the it's immediate preceding value.
na.locf(x)
# This function reverses the sequence
rev(x)
# if you want to replace the missing value with its immediate neighbors, here is the R code. This code is to show that missing value is replaced with it's preceding and succeeding values
na.locf(x)
rev(na.locf(rev(x)))
(na.locf(x) + rev(na.locf(rev(x))))/2
(na.locf(x) + rev(na.locf(rev(x))))/2
# Use the above code to replace the missing values
# in the Price variable
RtData2.Day2$MIN_PRICE=(na.locf(RtData2.Day2$MIN_PRICE) +
rev(na.locf(rev(RtData2.Day2$MIN_PRICE))))/2
pca_std <- princomp(x_train, cor = T)
rm(list=ls(all=T))
getwd()
setwd('E://Insofe//Week7//Day1//Lab//Day1//20180120//housing_data')
housing_raw <- read.csv('housing_data.csv', header = T, sep = ',')
rm(list=ls(all=T))
getwd()
setwd('E://Insofe//Week7//Day1//Lab//Day1//20180120//housing_data')
housing_raw <- read.csv('housing_data.csv', header = T, sep = ',')
summary(housing_raw)
str(housing_raw)
#is.na(housing_raw)
#na.omit(housing_raw)
housing_numeric <- subset(housing_raw, select = -c(CHAS,RAD))
library(DMwR)
housing_numeric <- knnImputation(housing_numeric)
sum(is.na(housing_numeric))
rows <- seq(1, nrow(housing_numeric),1)
set.seed(123)
trainRows <- sample(rows, 70* nrow(housing_numeric)/100)
housing_train <- housing_numeric[trainRows,]
housing_test <- housing_numeric[-trainRows,]
x_train <- housing_train[, -ncol(housing_train)]
x_test <- housing_test[, -ncol(housing_test)]
y_train <- housing_train[, ncol(housing_train)]
y_test <- housing_test[, ncol(housing_test)]
pca <- princomp(x_train)
pca$scores
pca$loadings
pca_std <- princomp(x_train, cor = T)
summary(pca)
summary(pca_std)
pca_train = predict(pca, x_train)
pca_test = predict(pca, x_test)
pca_std_train = predict(pca_std, x_train)
pca_std_test = predict(pca_std, x_test)
# linear model without pca
train2 = data.frame(x_train, y_train)
test2 = data.frame(x_test,y_test)
LinReg <- lm( y_train ~ ., data=train2)
summary(LinReg)
library(DMwR)
#Error verificatoin on train data
regr.eval(train2$y_train, LinReg$fitted.values)
#Error verification on test data
pred <- predict(LinReg, test2)
regr.eval(test2$y_test,pred)
#using PCA
train3 = data.frame(pca_train[,1:3], y_train)
test3 = data.frame(pca_test[,1:3], y_test)
LinRegpca <- lm(y_train~., data = train3)
summary(LinRegpca)
regr.eval(train3$y_train, LinRegpca$fitted.values)
predpca = predict(LinRegpca, test3)
regr.eval(test3$y_test, predpca)
#using standard pca
train4 = data.frame(pca_train[,1:7], y_train)
test4 = data.frame(pca_test[,1:7], y_test)
LinRegstdpca <- lm(y_train~., data = train4)
summary(LinRegstdpca)
regr.eval(train4$y_train, LinRegstdpca$fitted.values)
predstdpca = predict(LinRegstdpca, test4)
regr.eval(test4$y_test, predstdpca)
rm(list=ls(all=T))
getwd()
setwd('E://Insofe//Week7//Day1//Lab//Day1//20180120//housing_data')
housing_raw <- read.csv('housing_data.csv', header = T, sep = ',')
summary(housing_raw)
str(housing_raw)
#is.na(housing_raw)
#na.omit(housing_raw)
housing_numeric <- subset(housing_raw, select = -c(CHAS,RAD))
library(DMwR)
housing_numeric <- knnImputation(housing_numeric)
sum(is.na(housing_numeric))
rows <- seq(1, nrow(housing_numeric),1)
set.seed(123)
trainRows <- sample(rows, 70* nrow(housing_numeric)/100)
housing_train <- housing_numeric[trainRows,]
housing_test <- housing_numeric[-trainRows,]
x_train <- housing_train[, -ncol(housing_train)]
x_test <- housing_test[, -ncol(housing_test)]
y_train <- housing_train[, ncol(housing_train)]
y_test <- housing_test[, ncol(housing_test)]
pca <- princomp(x_train)
pca$scores
pca$loadings
pca_std <- princomp(x_train, cor = T)
summary(pca)
summary(pca_std)
pca_train = predict(pca, x_train)
pca_test = predict(pca, x_test)
pca_std_train = predict(pca_std, x_train)
pca_std_test = predict(pca_std, x_test)
# linear model without pca
train2 = data.frame(x_train, y_train)
test2 = data.frame(x_test,y_test)
LinReg <- lm( y_train ~ ., data=train2)
summary(LinReg)
library(DMwR)
#Error verificatoin on train data
regr.eval(train2$y_train, LinReg$fitted.values)
#Error verification on test data
pred <- predict(LinReg, test2)
regr.eval(test2$y_test,pred)
#using PCA
train3 = data.frame(pca_train[,1:3], y_train)
test3 = data.frame(pca_test[,1:3], y_test)
View(test2)
#Error verification on test data
pred <- predict(LinReg, test2)
regr.eval(test2$y_test,pred)
#using PCA
train3 = data.frame(pca_train[,1:3], y_train)
test3 = data.frame(pca_test[,1:3], y_test)
LinRegpca <- lm(y_train~., data = train3)
summary(LinRegpca)
regr.eval(train3$y_train, LinRegpca$fitted.values)
predpca = predict(LinRegpca, test3)
regr.eval(test3$y_test, predpca)
#using standard pca
train4 = data.frame(pca_train[,1:7], y_train)
test4 = data.frame(pca_test[,1:7], y_test)
LinRegstdpca <- lm(y_train~., data = train4)
summary(LinRegstdpca)
regr.eval(train4$y_train, LinRegstdpca$fitted.values)
#using standard pca
train4 = data.frame(pca_std_train[,1:7], y_train)
test4 = data.frame(pca_std_test[,1:7], y_test)
LinRegstdpca <- lm(y_train~., data = train4)
summary(LinRegstdpca)
regr.eval(train4$y_train, LinRegstdpca$fitted.values)
predstdpca = predict(LinRegstdpca, test4)
regr.eval(test4$y_test, predstdpca)
rm(list=ls(all=TRUE))
getwd()
setwd('E://Insofe//Week7//Day2//Lab')
load("Data.RData")
str(data)
dim(data)
head(data)
names(data)
tail(data)
library(sqldf) # to write SQL like commands in R to aggregate the data.
RtData2.Day <- sqldf("select Date,min(Price) as MIN_PRICE from data group by Date")
str(RtData2.Day)
RtData2.Day$Date=as.Date(RtData2.Day$Date,format="%Y-%m-%d")
str(RtData2.Day)
head(RtData2.Day) # we have missing values 02nd jan doesnt have an entry
minDate=min(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# To find the maximum of the dates
maxDate =max(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# generating the series of dates
seq <- data.frame("dateRange"=seq(minDate,maxDate,by="days"))
# left joining to see the missing values for the dates. all.x will do the left join."all.y" will do right join.
RtData2.Day2= merge(seq,RtData2.Day,by.x="dateRange",by.y="Date",all.x=T)
head(RtData2.Day2)
#   Here is the example to understand how "na.locf()"  function works
library(zoo)
x <- c(NA,1,2,3,4,5,NA,NA,NA,7,8,NA)
# na.locf function is used to replace the missing values. This will replace the missing value with the it's immediate preceding value.
na.locf(x)
# This function reverses the sequence
rev(x)
# if you want to replace the missing value with its immediate neighbors, here is the R code. This code is to show that missing value is replaced with it's preceding and succeeding values
na.locf(x)
rev(na.locf(rev(x)))
(na.locf(x) + rev(na.locf(rev(x))))/2
View(data)
RtData2.Day <- sqldf("select Date,min(Price) as MIN_PRICE from data group by Date")
str(RtData2.Day)
RtData2.Day$Date=as.Date(RtData2.Day$Date,format="%Y-%m-%d")
str(RtData2.Day)
head(RtData2.Day) # we have missing values 02nd jan doesnt have an entry
minDate=min(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# To find the maximum of the dates
maxDate =max(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# left joining to see the missing values for the dates. all.x will do the left join."all.y" will do right join.
RtData2.Day2= merge(seq,RtData2.Day,by.x="dateRange",by.y="Date",all.x=T)
head(RtData2.Day2)
# Use the above code to replace the missing values
# in the Price variable
RtData2.Day2$MIN_PRICE=(na.locf(RtData2.Day2$MIN_PRICE) +
rev(na.locf(rev(RtData2.Day2$MIN_PRICE))))/2
# Let us verify this before we move on.
head(RtData2.Day2)
str(RtData2.Day2)
head(RtData2.Day2)
# Let us verify this before we move on.
head(RtData2.Day2)
str(RtData2.Day2)
View(RtData2.Day2)
as.numeric(format(RtData2.Day2$dateRange,
format="%Y.%W"))
RtData2.Day2$WEEK <- as.numeric(format(RtData2.Day2$dateRange,
format="%Y.%W"))
head(RtData2.Day2)
# Now aggregating to weekly data
RtData2Day2 <- RtData2.Day2
head(RtData2Day2)
library(sqldf)
View(RtData2Day2)
RtData2.Week <- sqldf("select WEEK as WEEK,min(MIN_PRICE) as MIN_PRICE from RtData2Day2 group by WEEK")
View(RtData2.Week)
#Dividing data as Train & Test
Train=RtData2.Week[which(RtData2.Week$WEEK<=2013.37),]
Test=RtData2.Week[which(RtData2.Week$WEEK>2013.37),]
View(Train)
#Constucting a time series object
Price <- ts(Train$MIN_PRICE, frequency =52)
plot(Price,type="l",lwd=3,col="blue",xlab="week",ylab="Price", main="Time series plot")
pricedecomp <- decompose(Price)
plot(pricedecomp)
acf(Price,lag=30)
pacf(Price,lag=100)
pacf(Price,lag=30)
Price1 <- ts(Train$MIN_PRICE, frequency =1)
par(mfrow=c(1,2))
acf(Price1,lag=30)
par(mfrow=c(1,2))
acf(Price1,lag=30)
pacf(Price1,lag=30)
par(mfrow=c(1,2))
plot(diff(Price1,lag=1),type="l")
par(mfrow=c(1,2))
plot(diff(Price1,lag=1),type="l")
plot(diff(Price1,lag=2),type="l")
# The library TTR stands for Technical trading rules.
library(TTR)
fitsma <- SMA(Price,n=2)
length(fitsma)
length(Price)
fitsma
plot(fitsma)
#Let us see how this model performs. You could choose any of the error metrics. Here we used MAPE to compute the error.
smaMape <- mean(abs((Price[2:length(Price)]-fitsma[2:length(Price)])/Price[2:length(Price)]))
smaMape
TP=Test$MIN_PRICE
mean(abs((Price[2:length(Price)]-fitsma[2:length(Price)])/Price[2:length(Price)]))
fitwma<- WMA(Price,n=2,1:2)
fitEma <- EMA(Price, n = 2)
fitwma<- WMA(Price,n=2,1:2)
fitEma <- EMA(Price, n = 2)
emaMape <- mean(abs((Price[2:length(Price)]-fitEma[2:length(Price)])
/Price[2:length(Price)]))
emaMape
par(mfrow=c(2,2))
plot(Train$MIN_PRICE, type="l", col="black")
plot(fitsma, type="l", col="red")
plot(fitwma, type="l", col="blue")
plot(fitEma, type="l", col="brown")
par(mfrow=c(1,1))
plot(Train$MIN_PRICE, type="l", col="black")
lines(fitsma,col="red")
lines(fitwma, col="blue")
lines(fitEma, col="brown")
#Building the Holt winter's model taking only Trend component.
holtpriceforecast <- HoltWinters(Train$MIN_PRICE,  beta=TRUE, gamma=FALSE)
head(holtpriceforecast$fitted)# Look the fitted or forecasted values
priceholtforecast <-  HoltWinters(Price, beta=TRUE, gamma=TRUE,
seasonal="additive")
head(priceholtforecast$fitted)
head(priceholtforecast$fitted)
#Considering Train data
hw_price <- HoltWinters(Price , beta=TRUE, gamma=FALSE)
#hw_price_gamma <- HoltWinters(Price[1:260], beta=TRUE, gamma=TRUE, seasonal="additive")
hw_price$fitted
train_actuals <- Price[3:261]
train_pred <- data.frame(hw_price$fitted)[1]
DMwR::regr.eval(train_actuals,train_pred)
#hw_price_gamma <- HoltWinters(Price[1:260], beta=TRUE, gamma=TRUE, seasonal="additive")
hw_price$fitted
train_actuals <- Price[3:261]
train_pred <- data.frame(hw_price$fitted)[1]
DMwR::regr.eval(train_actuals,train_pred)
library("forecast")
hw_price_forecasts = forecast.HoltWinters(hw_price,h=1)
test_preds <- data.frame(hw_price_forecasts)$Point.Forecast
hw_price_forecasts = forecast.HoltWinters(hw_price,h=1)
hw_price_forecasts = forecast(hw_price,h=1)
test_preds <- data.frame(hw_price_forecasts)$Point.Forecast
#forecast.HoltWinters(hw_price,h=1)
test_actuals <- Test$MIN_PRICE
#OR test_actuals <- RtData2.Week$MIN_PRICE[262]
DMwR::regr.eval(test_actuals,test_preds)
#Building the Holt winter's model taking only Trend component.
holtpriceforecast <- HoltWinters(Train$MIN_PRICE,  beta=TRUE, gamma=FALSE)
head(holtpriceforecast$fitted)# Look the fitted or forecasted values
#hw_price_gamma <- HoltWinters(Price[1:260], beta=TRUE, gamma=TRUE, seasonal="additive")
#hw_price$fitted
train_actuals <- Train$MIN_PRICE
#train_pred <- data.frame(hw_price$fitted)[1]
length(priceholtforecast$fitted)
length(train_actuals)
rm(list=ls(all=TRUE))
getwd()
setwd('E://Insofe//Week7//Day2//Lab')
load("Data.RData")
str(data)
dim(data)
head(data)
names(data)
tail(data)
library(sqldf) # to write SQL like commands in R to aggregate the data.
RtData2.Day <- sqldf("select Date,min(Price) as MIN_PRICE from data group by Date")
str(RtData2.Day)
RtData2.Day$Date=as.Date(RtData2.Day$Date,format="%Y-%m-%d")
str(RtData2.Day)
head(RtData2.Day) # we have missing values 02nd jan doesnt have an entry
minDate=min(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# To find the maximum of the dates
maxDate =max(as.Date(RtData2.Day$Date,format="%Y-%m-%d"))
# generating the series of dates
seq <- data.frame("dateRange"=seq(minDate,maxDate,by="days"))
# left joining to see the missing values for the dates. all.x will do the left join."all.y" will do right join.
RtData2.Day2= merge(seq,RtData2.Day,by.x="dateRange",by.y="Date",all.x=T)
head(RtData2.Day2)
#   Here is the example to understand how "na.locf()"  function works
library(zoo)
x <- c(NA,1,2,3,4,5,NA,NA,NA,7,8,NA)
# na.locf function is used to replace the missing values. This will replace the missing value with the it's immediate preceding value.
na.locf(x)
# This function reverses the sequence
rev(x)
# if you want to replace the missing value with its immediate neighbors, here is the R code. This code is to show that missing value is replaced with it's preceding and succeeding values
na.locf(x)
rev(na.locf(rev(x)))
(na.locf(x) + rev(na.locf(rev(x))))/2
# Use the above code to replace the missing values
# in the Price variable
RtData2.Day2$MIN_PRICE=(na.locf(RtData2.Day2$MIN_PRICE) +
rev(na.locf(rev(RtData2.Day2$MIN_PRICE))))/2
# Let us verify this before we move on.
head(RtData2.Day2)
str(RtData2.Day2)
RtData2.Day2$WEEK <- as.numeric(format(RtData2.Day2$dateRange,
format="%Y.%W"))
head(RtData2.Day2)
# Now aggregating to weekly data
RtData2Day2 <- RtData2.Day2
head(RtData2Day2)
library(sqldf)
RtData2.Week <- sqldf("select WEEK as WEEK,min(MIN_PRICE) as MIN_PRICE from RtData2Day2 group by WEEK")
#Dividing data as Train & Test
Train=RtData2.Week[which(RtData2.Week$WEEK<=2013.37),]
Test=RtData2.Week[which(RtData2.Week$WEEK>2013.37),]
#Constucting a time series object
Price <- ts(Train$MIN_PRICE, frequency =52)
plot(Price,type="l",lwd=3,col="blue",xlab="week",ylab="Price", main="Time series plot")
pricedecomp <- decompose(Price)
plot(pricedecomp)
# we can choose any lag
acf(Price,lag=30)
pacf(Price,lag=30) # according to pacf seasonality is not there
priceholtforecast <-  HoltWinters(Price, beta=TRUE, gamma=TRUE,
seasonal="additive")
priceholtforecast
priceholtforecast <-  HoltWinters(Price, beta=TRUE, gamma=TRUE,
seasonal="additive")
DMwR::regr.eval(train_actuals,priceholtforecast$fitted[,1])
#hw_price_gamma <- HoltWinters(Price[1:260], beta=TRUE, gamma=TRUE, seasonal="additive")
#hw_price$fitted
train_actuals <- Train$MIN_PRICE
#train_pred <- data.frame(hw_price$fitted)[1]
length(priceholtforecast$fitted)
length(train_actuals)
DMwR::regr.eval(train_actuals,priceholtforecast$fitted[,1])
#hw_price_gamma <- HoltWinters(Price[1:260], beta=TRUE, gamma=TRUE, seasonal="additive")
#hw_price$fitted
train_actuals <- Train$MIN_PRICE[53:251]
#train_pred <- data.frame(hw_price$fitted)[1]
length(priceholtforecast$fitted)
length(train_actuals)
DMwR::regr.eval(train_actuals,priceholtforecast$fitted[,1])
hw_price_forecasts = forecast(hw_price,h=11)
library("forecast")
hw_price_forecasts = forecast(priceholtforecast,h=11)
hw_price_forecasts
test_preds <- data.frame(hw_price_forecasts)$Point.Forecast
#forecast.HoltWinters(hw_price,h=1)
test_actuals <- Test$MIN_PRICE
#OR test_actuals <- RtData2.Week$MIN_PRICE[262]
DMwR::regr.eval(test_actuals,test_preds)
